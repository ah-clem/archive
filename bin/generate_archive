#!/bin/bash

archive_gen_version="0.1.1"

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([output],[o],[output file or - for stdout, (required)])
# ARG_OPTIONAL_SINGLE([manifest],[m],[manifest file],[./manifest])
# ARG_OPTIONAL_SINGLE([archive],[a],[process existing archive (tar)])
# ARG_POSITIONAL_INF([sources],[sources to archive],[0],[.])
# ARG_HELP([Generate archive and manifest])
# ARG_VERSION([echo $0 $archive_gen_version])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='omahv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_sources=(".")
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_output=
_arg_manifest="./manifest"
_arg_archive=


print_help()
{
	printf '%s\n' "Generate archive and manifest"
	printf 'Usage: %s [-o|--output <arg>] [-m|--manifest <arg>] [-a|--archive <arg>] [-h|--help] [-v|--version] [<sources-1>] ... [<sources-n>] ...\n' "$0"
	printf '\t%s\n' "<sources>: sources to archive (defaults for <sources>: '.')"
	printf '\t%s\n' "-o, --output: output file or - for stdout, (required) (no default)"
	printf '\t%s\n' "-m, --manifest: manifest file (default: './manifest')"
	printf '\t%s\n' "-a, --archive: process existing archive (tar) (no default)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --version: Prints version"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-o|--output)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_output="$2"
				shift
				;;
			--output=*)
				_arg_output="${_key##--output=}"
				;;
			-o*)
				_arg_output="${_key##-o}"
				;;
			-m|--manifest)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_manifest="$2"
				shift
				;;
			--manifest=*)
				_arg_manifest="${_key##--manifest=}"
				;;
			-m*)
				_arg_manifest="${_key##-m}"
				;;
			-a|--archive)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_archive="$2"
				shift
				;;
			--archive=*)
				_arg_archive="${_key##--archive=}"
				;;
			-a*)
				_arg_archive="${_key##-a}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--version)
				echo $0 $archive_gen_version
				exit 0
				;;
			-v*)
				echo $0 $archive_gen_version
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names=""
	_our_args=$((${#_positionals[@]} - 0))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names="$_positional_names _arg_sources[$((ii + 0))]"
	done

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

#	generate_archive -- generate an encrypted tar archive along with a manifest
#			    suitable for long-term storage (disaster recovery).
#
#	type "generate_archive -h" for usage
#
#	Notes:
#		1. The archive is written to the named output destination (-o).  From there, it can be
#		   be transfered to long-term storage.
#		2. N.B. Hard and soft links are preserved.  Care should be taken when restoring from
#		   the archive.  E.g. hard links need to be contained within a single filesystem and
#		   soft links may have the incorrect context if they are not relative names.  Archiving
#		   of all hard links to a file is not checked by tar.
#		3. A "dry run" can be performed by setting the output to /dev/null (but could be
#		   expensive).  Alternatively, a recursive "du" will uncover some errors (access, filetype).
#		4. On MacOS, the "Terminal" will most likely need "Full Disk Access" for archives
#		   to be generated without certain access control errors.  See: System Preferences->
#		   Security & Privacy->Privacy->Full Disk Access.
#		5. Testing of all the various backup/restore situations has not been tested. This
#		   script is meant to create archives that can be manually (mostly) used to
#		   recover important files in a disaster situation.  Normal backups (e.g. Time
#		   Machine) are more suitable for day-to-day backup/recovery and recovering
#		   files deleted by accident.
#		6. The overhead of creating complete archives and transfering to long-term storage
#		   means that these archives will likely only be created and stored from time to
#		   time (every few months?).  Don't count on recovering the latest stuff!

sha_file="/tmp/sha.$$"
size_file="/tmp/size.$$"

clean() {
	/bin/rm -f "$sha_file" "$size_file"
}

abort() {
	clean
	die "${0}: aborting"
}

trap abort HUP INT TERM ERR

if [ ! ${_arg_output} ]
then
    die "Error: \"-o|--output <filename\"> must be specified."
fi

if [ "${_arg_archive}" -a \( ! -f "${_arg_archive}" -o ! -r "${_arg_archive}" \) ]
then
    die "Error: existing archive file \"${_arg_archive}\" not found or not a regualar, readable file"
fi

if [ "${_arg_archive}" -a "${_positionals_count}" != 0 ]
then
    die "Error: existing archive file or other sources must be defined, but not both"
fi

archive_gen_command="$0 $@"
archive_date_generated="$(date)"
archive_uname="$(uname -a)"
archive_cwd="$(pwd)"
archive_command=
archive_sources=
archive_sources_provided="${_positionals_count}"
archive_archive=
archive_output="$_arg_output"
archive_sha256=
archive_size=
archive_manifest="$_arg_manifest"
archive_gpg="$(which gpg)"
archive_gpg_version="$(gpg --version | head -1)"
archive_tar="$(which tar)"

if [ "$_arg_archive" ]
then
    archive_archive="$_arg_archive"
                     cat < "$_arg_archive"               | gpg -c | tee >(shasum -a 256 > "$sha_file") >(wc -c >"$size_file") | cat > "$_arg_output"
    archive_command="cat < "$_arg_archive"               | gpg -c | tee >(shasum -a 256 > "$sha_file") >(wc -c >"$size_file") | cat > "$_arg_output""
else
    archive_sources=( "${_arg_sources[@]}" )
                     tar -c -z -f - "${_arg_sources[@]}" | gpg -c | tee >(shasum -a 256 > "$sha_file") >(wc -c >"$size_file") | cat > "$_arg_output"
    archive_command="tar -c -z -f - "${_arg_sources[@]}" | gpg -c | tee >(shasum -a 256 > "$sha_file") >(wc -c >"$size_file") | cat > "$_arg_output""
fi

archive_sha256=$(cat "$sha_file")
archive_size=$(echo $(cat "$size_file"))

# print manifest

render_array() {
    	result="( "
	for i in "${@}"
	do
	    result+="\"$i\" "
	done
	result+=")"
	echo "$result"
}

(

cat <<- 'END'
#	Manifest of archive generated using "generate_archive".
#
#   The information below can be used manually or sourced into a shell script. But
#   be sure to strip off the information sections at the end!
#
#   N.B. 1. The quoted arguments that might, for example, contain white space are not
#           preserved in the commands recorded below.  To see the "source" information
#           for greater accuracy.
#        2. The default source (".") is ignored when an archive is specified ("-a").
#           The actual number of sources provided on the command line provided below.
#
#   The archive contents can be recovered using a script (i.e. extract_archive) which
#   is "automatic" and checks the size and sha.  Alternatively, the archive can be
#	easily checked and/or recovered manually.  Given an archive "archive":
#
#	$ shasum -a 256 < archive
#   $ gpg -d archive > archive.out
#   $ tar xf archive.out
#
#   For more details, see:
#	"generate_archive"
#	"extract_archive"
#	https://github.com/ah-clem/archive

END

    printf '# Sources provided on command line: %s\n' "$_positionals_count"
    for source in "${_arg_sources[@]}"
    do
	printf '# Source: %s\n' "$source"
    done

    echo

    printf 'archive_gen_command="%s"\n'		"$archive_gen_command"
    printf 'archive_gen_version="%s"\n'		"$archive_gen_version"
    printf 'archive_date_generated="%s"\n'	"$archive_date_generated"
    printf 'archive_uname="%s"\n'		"$archive_uname"
    printf 'archive_cwd="%s"\n'			"$archive_cwd"
    printf 'archive_command="%s"\n'		"$archive_command"
    printf 'archive_sources=%s\n'		"$(render_array "${archive_sources[@]}")"
    printf 'archive_sources_provided="%s"\n'	"$archive_sources_provided"
    printf 'archive_archive="%s"\n'		"$archive_archive"
    printf 'archive_output="%s"\n'		"$archive_output"
    printf 'archive_sha256="%s"\n'		"$archive_sha256"
    printf 'archive_size="%s"\n'		"$archive_size"
    printf 'archive_manifest="%s"\n'		"$archive_manifest"
    printf 'archive_gpg="%s"\n'			"$archive_gpg"
    printf 'archive_gpg_version="%s"\n'		"$archive_gpg_version"
    printf 'archive_tar="%s"\n'			"$archive_tar"

    printf '######### === BEGIN INFORMATION SECTION === #########\n'

    if [ "$_arg_archive" ]
    then
	printf '#### === BEGIN (tar) LS SECTION === ####\n'
	tar tvf "$_arg_archive"
	printf '#### === END (tar) LS SECTION === ####\n'
    else
	printf '#### === BEGIN DU SECTION === ####\n'
	du -s "${_arg_sources[@]}"
	printf '#### === END DU SECTION === ####\n'
	printf '#### === BEGIN LS SECTION === ####\n'
	ls -l -R -A "${_arg_sources[@]}"
	printf '#### === END LS SECTION === ####\n'
    fi

    printf '######### === END INFORMATION SECTION === #########\n'
) > "$archive_manifest"

clean

# ] <-- needed because of Argbash
