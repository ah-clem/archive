#!/bin/bash

archive_generate_version="0.3.0"

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([archive],[a],[use existing archive (tar); filename or - for stdin])
# ARG_OPTIONAL_SINGLE([manifest],[m],[manifest file],[./manifest])
# ARG_OPTIONAL_SINGLE([output],[o],[output file or - for stdout, (required)])
# ARG_POSITIONAL_INF([sources],[sources to archive],[0],[.])
# ARG_OPTIONAL_BOOLEAN([verbose],[],[write information to stderr])
# ARG_HELP([Generate archive and manifest])
# ARG_VERSION([echo $0 $archive_generate_version])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='amohv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_sources=(".")
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_archive=
_arg_manifest="./manifest"
_arg_output=
_arg_verbose="off"


print_help()
{
	printf '%s\n' "Generate archive and manifest"
	printf 'Usage: %s [-a|--archive <arg>] [-m|--manifest <arg>] [-o|--output <arg>] [--(no-)verbose] [-h|--help] [-v|--version] [<sources-1>] ... [<sources-n>] ...\n' "$0"
	printf '\t%s\n' "<sources>: sources to archive (defaults for <sources>: '.')"
	printf '\t%s\n' "-a, --archive: use existing archive (tar); filename or - for stdin (no default)"
	printf '\t%s\n' "-m, --manifest: manifest file (default: './manifest')"
	printf '\t%s\n' "-o, --output: output file or - for stdout, (required) (no default)"
	printf '\t%s\n' "--verbose, --no-verbose: write information to stderr (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --version: Prints version"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-a|--archive)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_archive="$2"
				shift
				;;
			--archive=*)
				_arg_archive="${_key##--archive=}"
				;;
			-a*)
				_arg_archive="${_key##-a}"
				;;
			-m|--manifest)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_manifest="$2"
				shift
				;;
			--manifest=*)
				_arg_manifest="${_key##--manifest=}"
				;;
			-m*)
				_arg_manifest="${_key##-m}"
				;;
			-o|--output)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_output="$2"
				shift
				;;
			--output=*)
				_arg_output="${_key##--output=}"
				;;
			-o*)
				_arg_output="${_key##-o}"
				;;
			--no-verbose|--verbose)
				_arg_verbose="on"
				test "${1:0:5}" = "--no-" && _arg_verbose="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--version)
				echo $0 $archive_generate_version
				exit 0
				;;
			-v*)
				echo $0 $archive_generate_version
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names=""
	_our_args=$((${#_positionals[@]} - 0))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names="$_positional_names _arg_sources[$((ii + 0))]"
	done

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

#	generate_archive -- generate an encrypted tar archive along with a manifest
#			    suitable for long-term storage (disaster recovery).
#
#	type "generate_archive -h" for usage
#
#	Notes:
#		1. The archive is written to the named output destination (-o).  From there, it can be
#		   be transfered to long-term storage.
#		2. N.B. Hard and soft links are preserved.  Care should be taken when restoring from
#		   the archive.  E.g. hard links need to be contained within a single filesystem and
#		   soft links may have the incorrect context if they are not relative names.  Archiving
#		   of all hard links to a file is not checked by tar.
#		3. A "dry run" can be performed by setting the output to /dev/null (but could be
#		   expensive).  Alternatively, a recursive "du" will uncover some errors (access, filetype).
#		4. On MacOS, the "Terminal" will most likely need "Full Disk Access" for archives
#		   to be generated without certain access control errors.  See: System Preferences->
#		   Security & Privacy->Privacy->Full Disk Access.
#		5. Testing of all the various backup/restore situations has not been tested. This
#		   script is meant to create archives that can be manually (mostly) used to
#		   recover important files in a disaster situation.  Normal backups (e.g. Time
#		   Machine) are more suitable for day-to-day backup/recovery and recovering
#		   files deleted by accident.
#		6. The overhead of creating complete archives and transfering to long-term storage
#		   means that these archives will likely only be created and stored from time to
#		   time (every few months?).  Don't count on recovering the latest stuff!

sha_file="/tmp/sha.$$"
size_file="/tmp/size.$$"

clean() {
	/bin/rm -f "$sha_file" "$size_file"
}

abort() {
	clean
	die "${0}: aborting"
}

verbose()
{
    if [ "${_arg_verbose}" = on ]
    then
	echo "$0" "$*" >&2
    fi
}

trap abort HUP INT TERM ERR

# argument symantic error checking

if [ -z ${_arg_output} ]
then
    die "Error: \"-o|--output <filename\"> must be specified."
fi

if [ -n "${_arg_archive}" ]
then
    if [ "${_positionals_count}" != 0 ]
    then
	die "Error: existing archive file or archive sources must be defined, but not both"
    fi
    if [ "${_arg_archive}" != '-' -a \( ! -f "${_arg_archive}" -o ! -r "${_arg_archive}" \) ]
    then
	die "Error: existing archive file \"${_arg_archive}\" not found or not a regular, readable file"
    fi
fi

# build variables for command use and manifest

archive_generate_command="$0 $@"
archive_date_generated="$(date)"
archive_uname="$(uname -a)"
archive_cwd="$(pwd)"
archive_command=
archive_sources=
archive_sources_provided="${_positionals_count}"
archive_archive=
archive_output="$_arg_output"
archive_sha256=
archive_size=
archive_manifest="$_arg_manifest"
archive_gpg="$(which gpg)"
archive_gpg_version="$(gpg --version | head -1)"
archive_tar="$(which tar)"

# build command pipeline according to options

cpipe=

if [ "$_arg_archive" ]
then
    archive_archive="$_arg_archive"
    if [ "$archive_archive" != '-' ]
    then
	cpipe+='cat < "$archive_archive" | '		# else, consume stdin
    fi
else
    archive_sources=( "${_arg_sources[@]}" )
    cpipe+='tar -c -z -f - "${archive_sources[@]}" | '
fi

cpipe+='gpg -c | tee >(shasum -a 256 > "$sha_file") >(wc -c >"$size_file")'

if [ $archive_output != "-" ]
then
    cpipe+=' | cat > "$archive_output"'			# else, just send to stdout
fi

archive_command="$cpipe"

verbose "running pipeline: '$cpipe'"

eval $cpipe						# here we go!

verbose "pipeline done"
verbose "generating manifest"

# print manifest

first() {
    echo $1
}

render_array() {
    	result="( "
	for i in "${@}"
	do
	    result+="\"$i\" "
	done
	result+=")"
	echo "$result"
}

archive_sha256=$(first $(cat "$sha_file"))
archive_size=$(first $(cat "$size_file"))

(

cat <<- 'END'
#	Manifest of archive generated using "generate_archive".
#
#   The information below can be used manually or sourced into a shell script. But
#   be sure to strip off the information sections at the end!
#
#   N.B. 1. The quoted arguments that might, for example, contain white space are not
#           preserved in the commands recorded below.  To see the "source" information
#           for greater accuracy.
#        2. The default source (".") is ignored when an archive is specified ("-a").
#           The actual number of sources provided on the command line provided below.
#
#   The archive contents can be recovered using a script (i.e. extract_archive) which
#   is "automatic" and checks the size and sha.  Alternatively, the archive can be
#   easily checked and/or recovered manually.  Given an archive "archive":
#
#   $ shasum -a 256 < archive
#   $ gpg -d archive > archive.out
#   $ tar xf archive.out
#
#   For more details, see:
#	"generate_archive"
#	"extract_archive"
#	https://github.com/ah-clem/archive

END

    printf '# Sources provided on command line: %s\n' "$_positionals_count"
    for source in "${archive_sources[@]}"
    do
	printf '# Source: %s\n' "$source"
    done

    echo

    printf 'archive_generate_command="%s"\n'	"$archive_generate_command"
    printf 'archive_generate_version="%s"\n'	"$archive_generate_version"
    printf 'archive_date_generated="%s"\n'	"$archive_date_generated"
    printf 'archive_uname="%s"\n'		"$archive_uname"
    printf 'archive_cwd="%s"\n'			"$archive_cwd"
    printf 'archive_command="%s"\n'		"$archive_command"
    printf 'archive_sources=%s\n'		"$(render_array "${archive_sources[@]}")"
    printf 'archive_sources_provided="%s"\n'	"$archive_sources_provided"
    printf 'archive_archive="%s"\n'		"$archive_archive"
    printf 'archive_output="%s"\n'		"$archive_output"
    printf 'archive_sha256="%s"\n'		"$archive_sha256"
    printf 'archive_size="%s"\n'		"$archive_size"
    printf 'archive_manifest="%s"\n'		"$archive_manifest"
    printf 'archive_gpg="%s"\n'			"$archive_gpg"
    printf 'archive_gpg_version="%s"\n'		"$archive_gpg_version"
    printf 'archive_tar="%s"\n'			"$archive_tar"

    printf '######### === BEGIN INFORMATION SECTION === #########\n'

    if [ "$archive_archive" ]
    then
	printf '#### === BEGIN (tar) LS SECTION === ####\n'
	tar tvf "$archive_archive"
	printf '#### === END (tar) LS SECTION === ####\n'
    else
	printf '#### === BEGIN DU SECTION === ####\n'
	du -s "${archive_sources[@]}"
	printf '#### === END DU SECTION === ####\n'
	printf '#### === BEGIN LS SECTION === ####\n'
	ls -l -R -A "${archive_sources[@]}"
	printf '#### === END LS SECTION === ####\n'
    fi

    printf '######### === END INFORMATION SECTION === #########\n'

) > "$archive_manifest"

verbose "manifest created: '$archive_manifest'"
verbose "done, cleaning up"

clean

# ] <-- needed because of Argbash
