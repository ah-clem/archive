#!/bin/bash

archive_extract_version="0.3.0"

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([archive],[a],[archive filename or - for stdin],[-])
# ARG_OPTIONAL_SINGLE([manifest],[m],[check using manifest file],[./manifest])
# ARG_OPTIONAL_SINGLE([output],[o],[write to output file or - for stdout (do not extract)])
# ARG_OPTIONAL_BOOLEAN([check],[c],[check archive (do not extract or write output)])
# ARG_OPTIONAL_BOOLEAN([nocheck],[C],[do not check archive])
# ARG_OPTIONAL_BOOLEAN([verbose],[],[write information to stderr])
# ARG_POSITIONAL_INF([targets],[targets to extract, extract all if no targets provided],[0])
# ARG_HELP([Extract and/or check archive])
# ARG_VERSION([echo $0 $archive_extract_version])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='amocChv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_targets=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_archive="-"
_arg_manifest="./manifest"
_arg_output=
_arg_check="off"
_arg_nocheck="off"
_arg_verbose="off"


print_help()
{
	printf '%s\n' "Extract and/or check archive"
	printf 'Usage: %s [-a|--archive <arg>] [-m|--manifest <arg>] [-o|--output <arg>] [-c|--(no-)check] [-C|--(no-)nocheck] [--(no-)verbose] [-h|--help] [-v|--version] [<targets-1>] ... [<targets-n>] ...\n' "$0"
	printf '\t%s\n' "<targets>: targets to extract, extract all if no targets provided"
	printf '\t%s\n' "-a, --archive: archive filename or - for stdin (default: '-')"
	printf '\t%s\n' "-m, --manifest: check using manifest file (default: './manifest')"
	printf '\t%s\n' "-o, --output: write to output file or - for stdout (do not extract) (no default)"
	printf '\t%s\n' "-c, --check, --no-check: check archive (do not extract or write output) (off by default)"
	printf '\t%s\n' "-C, --nocheck, --no-nocheck: do not check archive (off by default)"
	printf '\t%s\n' "--verbose, --no-verbose: write information to stderr (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --version: Prints version"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-a|--archive)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_archive="$2"
				shift
				;;
			--archive=*)
				_arg_archive="${_key##--archive=}"
				;;
			-a*)
				_arg_archive="${_key##-a}"
				;;
			-m|--manifest)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_manifest="$2"
				shift
				;;
			--manifest=*)
				_arg_manifest="${_key##--manifest=}"
				;;
			-m*)
				_arg_manifest="${_key##-m}"
				;;
			-o|--output)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_output="$2"
				shift
				;;
			--output=*)
				_arg_output="${_key##--output=}"
				;;
			-o*)
				_arg_output="${_key##-o}"
				;;
			-c|--no-check|--check)
				_arg_check="on"
				test "${1:0:5}" = "--no-" && _arg_check="off"
				;;
			-c*)
				_arg_check="on"
				_next="${_key##-c}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-c" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-C|--no-nocheck|--nocheck)
				_arg_nocheck="on"
				test "${1:0:5}" = "--no-" && _arg_nocheck="off"
				;;
			-C*)
				_arg_nocheck="on"
				_next="${_key##-C}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-C" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			--no-verbose|--verbose)
				_arg_verbose="on"
				test "${1:0:5}" = "--no-" && _arg_verbose="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--version)
				echo $0 $archive_extract_version
				exit 0
				;;
			-v*)
				echo $0 $archive_extract_version
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names=""
	_our_args=$((${#_positionals[@]} - 0))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names="$_positional_names _arg_targets[$((ii + 0))]"
	done

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

#	extract_archive -- extract from and/or check an encrypted tar archive.
#
#	type "extract_archive -h" for usage
#
#	Notes:
#		1. The encrypted archive is read from a named output destination (-a), from stdin (default).
#		   The archive's size and shasum can be checked against the manifest created during
#		   it's generation. The (decrypted) archive can be written out (-o) or used to
#		   extract the targets using tar.
#		2. N.B. Hard and soft links are preserved.  Care should be taken when restoring from
#		   the archive.  E.g. hard links need to be contained within a single filesystem and
#		   soft links may have the incorrect context if they are not relative names.  Archiving
#		   of all hard links to a file is not checked by tar.
#		3. A "dry run" can be performed by setting the output to /dev/null (but could be
#		   expensive).  The check-only option (-c) is cheaper: it checks without decrypting
#		   or writing output.
#		4. Disabling checking (-C) is useful when, for example, the manifest is not available.
#		   This script supports many combinations and options, but really the only thing
#		   needed to recover an archive generated by "generate_archive" is:
#			$ gpg -d < encrypted_archive > decrypted_archive
#		   This corresponds to:
#			$ extract_archive -a - -o - -C < encrypted_archive > decrypted_archive
#		5. Testing of all the various backup/restore situations has not been done. This
#		   script is meant to create archives that can be manually (mostly) used to
#		   recover important files in a disaster situation.  Normal backups (e.g. Time
#		   Machine) are more suitable for day-to-day backup/recovery and recovering
#		   files deleted by accident.
#		6. The overhead of creating/recovering complete archives and transfering to long-term storage
#		   means that these archives will likely only be created and stored from time to
#		   time (every few months?).  Don't count on recovering the latest stuff!
#
#	See: generate_archive

sha_file="/tmp/sha.$$"
size_file="/tmp/size.$$"
manifest_file="/tmp/manifest.$$"

clean() {
	/bin/rm -f "$sha_file" "$size_file" "$manifest_file"
}

abort() {
	clean
	die "${0}: aborting"
}

verbose()
{
    if [ "${_arg_verbose}" = on ]
    then
	echo "$0" "$*" >&2
    fi
}

trap abort HUP INT TERM ERR

# argument symantic error checking

if [ "${_arg_archive}" != '-' -a \( ! -f "${_arg_archive}" -o ! -r "${_arg_archive}" \) ]
then
    die "Error: archive file \"${_arg_archive}\" not found or not a regular, readable file"
fi

if [ "${_arg_nocheck}" != 'on' -a \( ! -f "${_arg_manifest}" -o ! -r "${_arg_manifest}" \) ]
then
    die "Error: manifest file \"${_arg_manifest}\" not found or not a regular, readable file."
fi

if [ "${_arg_check}" == 'on' -a "${_arg_nocheck}" == 'on' ]
then
    die "Error: ambigious arguments: \"--check\" and \"--nocheck\" both set."
fi

if [ "${_arg_check}" == 'on' -a -n "${_arg_output}" ]
then
    die "Error: ambigious arguments: \"--check\" and \"--output\" both set."
fi

# source leading lines of manifest file

if [ "${_arg_nocheck}" != 'on' ]
then
    verbose "loading manifest file: '${_arg_manifest}'"
    sed -n -e '1,/=== BEGIN INFORMATION SECTION ===/p' "${_arg_manifest}" > "${manifest_file}"
    . "${manifest_file}"
fi

#	render_array() {
#	    	result="( "
#		for i in "${@}"
#		do
#		    result+="\"$i\" "
#		done
#		result+=")"
#		echo "$result"
#	}

#	printf 'archive_generate_command="%s"\n'	"$archive_generate_command"
#	printf 'archive_generate_version="%s"\n'	"$archive_generate_version"
#	printf 'archive_date_generated="%s"\n'		"$archive_date_generated"
#	printf 'archive_uname="%s"\n'			"$archive_uname"
#	printf 'archive_cwd="%s"\n'			"$archive_cwd"
#	printf 'archive_command="%s"\n'			"$archive_command"
#	printf 'archive_sources=%s\n'			"$(render_array "${archive_sources[@]}")"
#	printf 'archive_sources_provided="%s"\n'	"$archive_sources_provided"
#	printf 'archive_archive="%s"\n'			"$archive_archive"
#	printf 'archive_output="%s"\n'			"$archive_output"
#	printf 'archive_sha256="%s"\n'			"$archive_sha256"
#	printf 'archive_size="%s"\n'			"$archive_size"
#	printf 'archive_manifest="%s"\n'		"$archive_manifest"
#	printf 'archive_gpg="%s"\n'			"$archive_gpg"
#	printf 'archive_gpg_version="%s"\n'		"$archive_gpg_version"
#	printf 'archive_tar="%s"\n'			"$archive_tar"

# build command pipeline according to options

cpipe=

for dummy in 1					# do once, at most
do
    # get input from file or stdin
    if [ "$_arg_archive" != '-' ]
    then
	cpipe+='cat < "$_arg_archive" | '	# else, consume stdin
    fi

    # check or not
    if [ "${_arg_nocheck}" == 'off' ]
    then
	if [ "${_arg_check}" == 'on' ]
	then
	    cpipe+='tee >(shasum -a 256 > "$sha_file") | wc -c >"$size_file"'
	    break;				# nothing more to add to pipeline
	else
	    cpipe+='tee >(shasum -a 256 > "$sha_file") >(wc -c >"$size_file") | '
	fi
    fi

    cpipe+='gpg -d'

    # either extract or write decypted archive to file/stdout
    if [ -z "${_arg_output}" ]
    then
	cpipe+=' | tar -x -z -f - "${_arg_targets[@]}"'
    elif [ "${_arg_output}" != '-' ]
    then
	cpipe+=' | cat > "${_arg_output}"'	# else, send to stdout
    fi
done

verbose "running pipeline: '$cpipe'"

eval $cpipe					# here we go!

verbose "pipeline done"

# do checking as needed

first() {
    echo $1
}

if [ "${_arg_nocheck}" != 'on' ]
then
    verbose "checking archive"
    checked_sha256=$(first $(cat "$sha_file"))
    checked_size=$(first $(cat "$size_file"))
    if [ "${checked_sha256}" = "${archive_sha256}" -a "${checked_size}" = "${archive_size}" ]
    then
	verbose "archive checks ok"
    else
	die "check of archive against manifest failed (archive / manifest): ${checked_sha256} / ${archive_sha256} ; ${checked_size} / ${archive_size}"
    fi
fi

verbose "done, cleaning up"

clean

# ] <-- needed because of Argbash
